<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Computer Science and Math related projects by Carlos Ojeda de Silva – Carlos Ojeda de Silva Portfolio Website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-01c78b5cd655e4cd89133cf59d535862.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-274c3d255ff4b40ad85bc0e900837b3c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Carlos Ojeda de Silva Portfolio Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../engineering/"> 
<span class="menu-text">Engineering Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../coding/"> 
<span class="menu-text">Math/Computer Science Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#finding-the-best-route-between-several-points-using-ai" id="toc-finding-the-best-route-between-several-points-using-ai" class="nav-link active" data-scroll-target="#finding-the-best-route-between-several-points-using-ai">Finding the best route between several points using AI</a></li>
  <li><a href="#predicting-the-shape-of-a-photographed-object-using-ai" id="toc-predicting-the-shape-of-a-photographed-object-using-ai" class="nav-link" data-scroll-target="#predicting-the-shape-of-a-photographed-object-using-ai">Predicting the shape of a photographed object using AI</a></li>
  <li><a href="#finding-the-area-under-a-hyperbola-using-rotations." id="toc-finding-the-area-under-a-hyperbola-using-rotations." class="nav-link" data-scroll-target="#finding-the-area-under-a-hyperbola-using-rotations.">Finding the area under a hyperbola using rotations.</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Computer Science and Math related projects by Carlos Ojeda de Silva</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="finding-the-best-route-between-several-points-using-ai" class="level2">
<h2 class="anchored" data-anchor-id="finding-the-best-route-between-several-points-using-ai">Finding the best route between several points using AI</h2>
<div class="panel">
<button id="showMoreButton1" onclick="toggleText1()" style="position: relative; background-color: #2E5CA7; color: white; border: none; padding: 0; cursor: pointer; border-radius: 5px; width: 200px; height: 200px; overflow: hidden;">
<img id="buttonImage1" src="../images/routes.png" alt="Icon" style="width: 100%; height: 100%; object-fit: cover;"> <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 3px;">Show More:</span>
</button>
<div id="hiddenText1" style="display: none; margin-top: 10px;">
<p>If an Amazon/UPS/FedEx driver wants to deliver goods to 2 homes, how many different routes are possible, and how do you find the best one? Answer: 2 routes determined by trial and error. Having 20 homes increases the possible routes to 2,432,902,008,176,640,000, which is too much to do with trial and error. This is a really important problem to solve because it would massively reduce gasoline usage around the world. It isn’t logical to do trial and error if we have a lot of homes, so I took a different approach: Making an AI model that can predict (or get close to) what would be the best route from the coordinates.</p>
<p>This was done on a small scale since it would take a long time for my computer to generate a dataset to train the AI with many homes. The data was made by plugging random coordinates (in San Antonio Texas as a small-scale test) into a Python program called Open Street Maps that generates travel times for a route between 2 points in the map, this was done with 4 points (12 times in total since the order was ignored: 4!/2).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Routes_dataset.png" class="img-fluid figure-img"></p>
<figcaption>Dataset used</figcaption>
</figure>
</div>
<p>The tests done on the data were convincing since a Random Forest AI model was able to correctly guess approximately 40% of the routes, and on average, was 10% longer than the perfect route (compared to 40% longer for random routes). This test was able to show that AI can be used to approximate a generally close answer in problems that would otherwise require a lot of computing.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Routes.png" class="img-fluid figure-img"></p>
<figcaption>Results of AI algorithm</figcaption>
</figure>
</div>
</div>
<script>
function toggleText1() {
    var hiddenText = document.getElementById("hiddenText1");
    var button = document.getElementById("showMoreButton1");
    var buttonImage = document.getElementById("buttonImage1");
    var buttonText = button.querySelector("span"); // Only target the text part of the button

    if (hiddenText.style.display === "none") {
        hiddenText.style.display = "block";
        buttonImage.style.display = "none"; // Hide the image
        buttonText.innerText = "Show Less";
    } else {
        hiddenText.style.display = "none";
        buttonImage.style.display = "block"; // Show the image
        buttonText.innerText = "Show More";
    }
}
</script>
</div>
</section>
<section id="predicting-the-shape-of-a-photographed-object-using-ai" class="level2">
<h2 class="anchored" data-anchor-id="predicting-the-shape-of-a-photographed-object-using-ai">Predicting the shape of a photographed object using AI</h2>
<div class="panel">
<button id="showMoreButton2" onclick="toggleText2()" style="position: relative; background-color: #2E5CA7; color: white; border: none; padding: 0; cursor: pointer; border-radius: 5px; width: 480px; height: 80px; overflow: hidden;">
<img id="buttonImage2" src="../images/Depth_result.png" alt="Icon" style="width: 100%; height: 100%; object-fit: cover;"> <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 3px;">Show More:</span>
</button>
<div id="hiddenText2" style="display: none; margin-top: 10px;">
<p>Have you ever wondered if robots can know the shape of the world around them from a single camera in a similar way to how we know how far things are? Well, this project aims to develop a simple AI algorithm that can do that.</p>
<p>This project used an open source dataset named <strong><a href="https://diode-dataset.org/">Diode Dataset</a></strong> where there are depth maps associated with images.</p>
<p><img src="..\images/Depth_dataset.png" class="img-fluid" alt="Original Dataset"> For this project based on computing limitations, only the validation and test images were used.</p>
<p>Some pre-processing was done, which is described below:</p>
<p>-The top 5% and bottom 5% of depth values are clipped. -The data is then scaled to be in the range [0,1] -The natural log of the pixel values + 0.05 is taken. -The data is scaled again to be in the range [0,1] -Image resolution was decreased from 1024x784 into 256x192.</p>
<p>For this project, a Convolutional Neural Network with less than 500,000 parameters was used, this was with the purpose to widen the application scopes of this model. Although the algorithm was able to predict general shapes at its best, more work is needed in order to apply it as a solution for computer vision.</p>
<p><img src="..\images/Depth_result.png" class="img-fluid" alt="Results of AI algorithm"> Although this specific example had a good prediction of shape, most images produced noisier predictions.</p>
</div>
<script>
function toggleText2() {
    var hiddenText = document.getElementById("hiddenText2");
    var button = document.getElementById("showMoreButton2");
    var buttonImage = document.getElementById("buttonImage2");
    var buttonText = button.querySelector("span"); // Only target the text part of the button

    if (hiddenText.style.display === "none") {
        hiddenText.style.display = "block";
        buttonImage.style.display = "none"; // Hide the image
        buttonText.innerText = "Show Less";
    } else {
        hiddenText.style.display = "none";
        buttonImage.style.display = "block"; // Show the image
        buttonText.innerText = "Show More";
    }
}
</script>
</div>
</section>
<section id="finding-the-area-under-a-hyperbola-using-rotations." class="level2">
<h2 class="anchored" data-anchor-id="finding-the-area-under-a-hyperbola-using-rotations.">Finding the area under a hyperbola using rotations.</h2>
<div class="panel">
<button id="showMoreButton3" onclick="toggleText3()" style="position: relative; background-color: #2E5CA7; color: white; border: none; padding: 0; cursor: pointer; border-radius: 5px; width: 200px; height: 200px; overflow: hidden;">
<img id="buttonImage3" src="../images/Hyperbola5.png" alt="Icon" style="width: 100%; height: 100%; object-fit: cover;"> <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; font-weight: bold; background-color: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 3px;">Show More:</span>
</button>
<div id="hiddenText3" style="display: none; margin-top: 10px;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola1.png" class="img-fluid figure-img"></p>
<figcaption>Rotated Hyperbola with Areas</figcaption>
</figure>
</div>
<p>By only knowing that the integral of 1/x is ln|x| and how to use polar equations (or Euler’s formula), it is possible to find the integral of a hyperbola. This isn’t normally seen up until Calculus II. The Integral (Area under the curve) of y^2 - x^2 = 2 was calculated through the 45° rotation of a y=1/x graph and finding the areas composing it on the graph. This approach clearly shows why the area under a hyperbola depends on a natural logarithm and other properties it has. <strong><a href="https://www.desmos.com/calculator/0qavllu7bp">Here is an interactive representation of this process</a></strong></p>
<p>Hyperbolas are interesting shapes, but it is initially quite hard to know how to work with them, especially when integrating. Here I show an alternative method for finding the integral of a hyperbola using first-month knowledge of high school Calculus. First, we start by proving that y = 1/x is a hyperbola. We will define a hyperbola as one having the general form: y^2 - x^2 = a. This can be done with polar equations or with Euler’s formula. In this case, I will show how to do it both ways to demonstrate how it can be done quickly or with basic knowledge.</p>
<p>This example uses polar coordinates to rotate a y = 1/x graph 45° or π/4 angle and arriving to y^2 - x^2 = 2</p>
<p><img src="..\images/Hyperbola2.png" class="img-fluid"></p>
<div class="grid">
<div class="g-col-6">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola3.png" class="img-fluid figure-img"></p>
<figcaption>Polar Coordinate method</figcaption>
</figure>
</div>
</div>
<div class="g-col-6">
<p><img src="..\images/Hyperbola4.png" class="img-fluid" alt="Euler’s Equation Method"> |</p>
</div>
</div>
<p><strong>Calculating the specific areas:</strong></p>
<p>From the figure below, we can see two lines: one passing through y=x and another one labeled P. There are four areas labeled A, B, C, and D, these areas can be calculated through different equations. First, let’s solve the easiest ones: A and D.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola5.png" class="img-fluid figure-img"></p>
<figcaption>Labeled Areas</figcaption>
</figure>
</div>
<p>A stays constant since it represents a triangle made from an isosceles triangle with a base and height of 1, which doesn’t depend on the position of line P.</p>
<p>The Area of D is ½P^2 since the triangle has a base and height equal to P.</p>
<p>To get the other two areas, we need to define the line going from 0,0 to the right-most corner of the triangle C as a new axis L. L has the length of the base of the original y=1x graph used, which allows us to get the area of that shape using a natural logarithm. The image below shows the point where L is measured from.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola6.png" class="img-fluid figure-img"></p>
<figcaption>Ponit L</figcaption>
</figure>
</div>
<p>Based on the image above. Area C, having a base on the x-axis in the original y = 1/x graph, makes it easier to calculate in terms of L for the rotated graph. We know that in the original y = 1/x graph the height of the triangle is y and it was formed by a 45° or π/4 angle, meaning that both lines LM and LN have the same length. Knowing that LN = y, we can determine the area to be equal to ½(1/L)^2 since both the base and height in the rotated triangle need to be 1/L.</p>
<p>We also need to consider that L doesn’t lie exactly on P, meaning that we need to remove the segment LM from length L to get length P. Thankfully, we already know what LM is, meaning that we can create a formula to calculate P based on L. Using the quadratic formula, we can solve for L, giving us the last step in finding the integral of the hyperbola. We are using the positive variation in the quadratic formula since we will not account for the negative y-values on the graph.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola7.png" class="img-fluid figure-img"></p>
<figcaption>Calculating Area B</figcaption>
</figure>
</div>
<p>After getting all of the formulas needed, it is now just adding them together. Note that the formula we are using is y = √(x^2+2), this was done because y^2 - x^2 = 2 is not a function, but it does graph the same curve for positive y values.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="..\images/Hyperbola8.png" class="img-fluid figure-img"></p>
<figcaption>Final simplification</figcaption>
</figure>
</div>
</div>
<script>
function toggleText3() {
    var hiddenText = document.getElementById("hiddenText3");
    var button = document.getElementById("showMoreButton3");
    var buttonImage = document.getElementById("buttonImage3");
    var buttonText = button.querySelector("span"); // Only target the text part of the button

    if (hiddenText.style.display === "none") {
        hiddenText.style.display = "block";
        buttonImage.style.display = "none"; // Hide the image
        buttonText.innerText = "Show Less";
    } else {
        hiddenText.style.display = "none";
        buttonImage.style.display = "block"; // Show the image
        buttonText.innerText = "Show More";
    }
}
</script>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>